#version 450
// Allows us to use glDispatchComputeGroupSize to choose computation layout
#extension GL_ARB_compute_variable_group_size : enable
layout(local_size_variable) in;

layout(rgba8, binding = 0)   uniform image2D uImageInput;

#define MAX_DOTS 16384

struct shader_dot {
    float x;
    float y;
    float rx;
    float ry;
    float L;
    float a;
    float b;
};

layout(std430, binding = 1) buffer ssbo_data {
    shader_dot Dots[MAX_DOTS];
    int NumDots;
};

uniform float uMaxRadius;
uniform float uMinRadius;

// TODO: Make these uniforms that are passed in.
int uMaxChances = 3;
float uTolerance = 0.20;

// ----------------------------------------------------------------------------
// Utility

vec4 getColor(ivec2 p) {
    return imageLoad(uImageInput, p);
}


// ----------------------------------------------------------------------------
// Dot detection algorithm

// The maximum difference between two colors looking at each channel (r, g, b).
float colorDiff(vec4 b, vec4 a) {
    vec4 d = b - a;
    return max(max(d.r, d.g), d.b);
}

vec2 radiusOfDot(ivec2 position) {
    vec2 nope = vec2(-1, -1);

    vec4 core = getColor(position);

    int chances = uMaxChances;

    for (int r = 1; r < uMaxRadius; r++) {
        // TODO: Is this the proper coordinate system? By symmetry it doesn't
        // matter but it would be nice for up, down, left, right to mean the
        // correct thing...
        vec4 up_color = getColor(position + ivec2(1,0)*r);
        vec4 down_color = getColor(position + ivec2(-1,0)*r);
        vec4 right_color = getColor(position + ivec2(0,1)*r);
        vec4 left_color = getColor(position + ivec2(0,-1)*r);
        float du = colorDiff(up_color, core);
        float dd = colorDiff(down_color, core);
        float dr = colorDiff(right_color, core);
        float dl = colorDiff(left_color, core);

        int num_hits = ((du > uTolerance) ? 1 : 0) +
                      ((dd > uTolerance) ? 1 : 0) +
                      ((dr > uTolerance) ? 1 : 0) +
                      ((dl > uTolerance) ? 1 : 0);

        if (num_hits == 4) {
            if (r < uMinRadius) { return nope; }

            // Uncomment below to disable the diagonal check.
            // return vec2(r,r);

            // Potentially found a dot. Check diagonals.
            int diagonal_distance = int(ceil(float(r) / sqrt(2)));
            vec4 ur_color = getColor(position + ivec2(1,1)*diagonal_distance);
            vec4 ul_color = getColor(position + ivec2(1,-1)*diagonal_distance);
            vec4 dr_color = getColor(position + ivec2(-1,1)*diagonal_distance);
            vec4 dl_color = getColor(position + ivec2(-1,-1)*diagonal_distance);
            float dur = colorDiff(ur_color, core);
            float dul = colorDiff(ul_color, core);
            float ddr = colorDiff(dr_color, core);
            float ddl = colorDiff(dl_color, core);
            if (dur > uTolerance && dul > uTolerance && ddr > uTolerance && ddl > uTolerance) {
                // Diagonals all check out. We found a dot!
                return vec2(r,r);
            }
            return nope;
        }
        if (num_hits > 0) { chances--; }
        if (chances == 0) { return nope; }
    }
    return nope;
}


// ----------------------------------------------------------------------------
// Extracting the color of a (found) dot

// Expects r, g, b in range 0 to 1.
// Outputs LAB in range L (0 to 100), A (-128 to 128), B (-128 to 128).
vec3 rgbToLab(vec4 rgb) {
    float r = rgb.r;
    float g = rgb.g;
    float b = rgb.b;

    r = (r > 0.04045) ? pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = (g > 0.04045) ? pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = (b > 0.04045) ? pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

    float x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
    float y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
    float z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;

    x = (x > 0.008856) ? pow(x, 1.0/3) : (7.787 * x) + 16.0/116;
    y = (y > 0.008856) ? pow(y, 1.0/3) : (7.787 * y) + 16.0/116;
    z = (z > 0.008856) ? pow(z, 1.0/3) : (7.787 * z) + 16.0/116;

    return vec3((116.0 * y) - 16, 500.0 * (x - y), 200.0 * (y - z));
}

// Extracts the (gaussian weighted average) color within an ellipse (in RGB color space).
vec4 colorForDot(ivec2 position, vec2 radius) {
    vec4 sum = vec4(0.0);
    float totalWeight = 0.0;

    for (int x = int(floor(position.x - radius.x)); x <= int(ceil(position.x + radius.x)); x++) {
        for (int y = int(floor(position.y - radius.y)); y <= int(ceil(position.y + radius.y)); y++) {
            // contract radius by 1.5 px, to avoid edge effects
            float dx = (x - position.x) / max(1.0, radius.x - 1.5);
            float dy = (y - position.y) / max(1.0, radius.y - 1.5);
            float d2 = dx*dx + dy*dy;
            if (d2 > 1) { continue; }  // ignore pixels outside the ellipse

            float w = exp(-d2 * log(10));  // weight with gaussian that drops to 1/10 at edge of ellipse
            sum += w * getColor(ivec2(x, y));
            totalWeight += w;
        }
    }
    return sum / totalWeight;
}


// ----------------------------------------------------------------------------
// Main

void addDot(ivec2 position, vec2 radius) {
    // Use atomicAdd to get an index into our shared storage array
    int Index = atomicAdd(NumDots, 1);
    if (Index < Dots.length()) {
        // vec4 rgb = getColor(position);
        vec4 rgb = colorForDot(position, radius);
        vec3 lab = rgbToLab(rgb);
        Dots[Index] = shader_dot(float(position.x), float(position.y), radius.x, radius.y, lab.x, lab.y, lab.z);
    }
}

void main() {
    ivec2 position = ivec2(gl_GlobalInvocationID.xy);

    vec2 r = radiusOfDot(position);
    if (r.x > 0) {  // found a dot
        addDot(position, r);
    }
}
